use std::mem::MaybeUninit;
use std::sync::Arc;
use std::str::FromStr;
use std::fs::File;

use anyhow::{Context, Result};
use clap::Parser;
use daemonize::Daemonize;
use libbpf_rs::skel::{OpenSkel, SkelBuilder};
use nix::net::if_::if_nametoindex;

#[global_allocator]
static GLOBAL: mimalloc::MiMalloc = mimalloc::MiMalloc;

pub mod access_log;
pub mod access_rules;
pub mod app_state;
pub mod captcha_server;
pub mod cli;
pub mod content_scanning;
pub mod firewall;
pub mod http_client;
pub mod waf;
pub mod threat;
pub mod redis;
pub mod proxy_protocol;
pub mod authcheck;
pub mod http_proxy;
pub mod bpf {
    // Include the skeleton generated by build.rs into OUT_DIR at compile time
    include!(concat!(env!("OUT_DIR"), "/filter.skel.rs"));
}

pub mod bpf_stats;
pub mod ja4_plus;
pub mod utils;
pub mod worker;
pub mod acme;

use tokio::signal;
use tokio::sync::watch;
use log::{error, info, warn};

use crate::app_state::AppState;
use crate::bpf_stats::BpfStatsCollector;
use crate::utils::tcp_fingerprint::TcpFingerprintCollector;
use crate::utils::tcp_fingerprint::TcpFingerprintConfig;
use crate::cli::{Args, Config};
use crate::waf::wirefilter::init_config;
use crate::content_scanning::{init_content_scanner, ContentScanningConfig};
use crate::utils::bpf_utils::{bpf_attach_to_xdp, bpf_detach_from_xdp};

use crate::access_log::LogSenderConfig;
use crate::worker::log::set_log_sender_config;
use crate::authcheck::validate_api_key;
use crate::http_client::init_global_client;
use crate::waf::actions::captcha::{CaptchaConfig, CaptchaProvider, init_captcha_client, start_cache_cleanup_task};

fn main() -> Result<()> {
    // Initialize rustls crypto provider early (must be done before any rustls operations)
    rustls::crypto::ring::default_provider()
        .install_default()
        .map_err(|e| anyhow::anyhow!("Failed to install rustls crypto provider: {:?}", e))?;

    let args = Args::parse();

    // Validate required arguments when no config file is provided
    if args.config.is_none() {
        if args.arxignis_api_key.is_none() {
            return Err(anyhow::anyhow!("--arxignis-api-key is required when no config file is provided"));
        }
    }

    // Load configuration
    let config = Config::load_from_args(&args)
        .context("Failed to load configuration")?;

    // Handle daemonization before starting tokio runtime
    if config.daemon.enabled {
        let stdout = File::create(&config.daemon.stdout)
            .with_context(|| format!("Failed to create stdout file: {}", config.daemon.stdout))?;
        let stderr = File::create(&config.daemon.stderr)
            .with_context(|| format!("Failed to create stderr file: {}", config.daemon.stderr))?;

        let mut daemonize = Daemonize::new()
            .pid_file(&config.daemon.pid_file)
            .chown_pid_file(config.daemon.chown_pid_file)
            .working_directory(&config.daemon.working_directory)
            .stdout(stdout)
            .stderr(stderr);

        if let Some(user) = &config.daemon.user {
            daemonize = daemonize.user(user.as_str());
        }

        if let Some(group) = &config.daemon.group {
            daemonize = daemonize.group(group.as_str());
        }

        match daemonize.start() {
            Ok(_) => {
                // We're now in the daemon process, continue with application startup
            }
            Err(e) => {
                eprintln!("Failed to daemonize: {}", e);
                return Err(anyhow::anyhow!("Daemonization failed: {}", e));
            }
        }
    }

    // Set RUST_LOG environment variable from config so other modules can use it
    let log_level = if !config.logging.level.is_empty() {
        config.logging.level.to_lowercase()
    } else {
        match args.log_level {
            crate::cli::LogLevel::Error => "error",
            crate::cli::LogLevel::Warn => "warn",
            crate::cli::LogLevel::Info => "info",
            crate::cli::LogLevel::Debug => "debug",
            crate::cli::LogLevel::Trace => "trace",
        }.to_string()
    };
    unsafe {
        std::env::set_var("RUST_LOG", &log_level);
    }

    // Initialize logger using config level (CLI overrides if provided explicitly)
    // Note: env_logger writes to stderr by default, which is standard practice
    {
        use env_logger::Env;
        let mut builder = env_logger::Builder::from_env(Env::default().default_filter_or("info"));

        // Use log level from config, or CLI if explicitly set
        let level_filter = match log_level.as_str() {
            "error" => log::LevelFilter::Error,
            "warn" => log::LevelFilter::Warn,
            "info" => log::LevelFilter::Info,
            "debug" => log::LevelFilter::Debug,
            "trace" => log::LevelFilter::Trace,
            _ => args.log_level.to_level_filter(),
        };
        builder.filter_level(level_filter);
        builder.format_timestamp_secs();

        // In daemon mode, write to stdout instead of stderr for better log separation
        if config.daemon.enabled {
            builder.target(env_logger::Target::Stdout);
        }

        builder.try_init().ok();
    }

    // Start the tokio runtime and run the async application
    tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()?
        .block_on(async_main(args, config))
}

#[allow(clippy::too_many_lines)]
async fn async_main(_args: Args, config: Config) -> Result<()> {

    if config.daemon.enabled {
        log::info!("Running in daemon mode (PID file: {})", config.daemon.pid_file);
    }

    // Log mode and active features
    if config.mode == "agent" {
        log::info!("Running in AGENT mode - BPF, access rules, TCP fingerprinting, and logging are active");
        log::info!("Agent mode features: XDP packet filtering, access rules enforcement, TCP fingerprinting, BPF statistics, and event logging");
    } else {
        log::info!("Running in PROXY mode - Full reverse proxy with all security features");
    }

    // Initialize global HTTP client with keepalive configuration
    if let Err(e) = init_global_client() {
        log::warn!("Failed to initialize global HTTP client: {}", e);
    } else {
        log::info!("Global HTTP client initialized with keepalive configuration");
    }


    let iface_names: Vec<String> = if !config.network.ifaces.is_empty() {
        config.network.ifaces.clone()
    } else {
        vec![config.network.iface.clone()]
    };

    let mut skels: Vec<Arc<bpf::FilterSkel<'static>>> = Vec::new();
    let mut ifindices: Vec<i32> = Vec::new();

    if config.network.disable_xdp {
        log::info!("XDP disabled by config, skipping BPF attachment");
        log::info!("Access rules will be enforced in userland (application layer) instead of kernel level");
        log::info!("Note: Userland enforcement has higher latency than XDP but still provides IP blocking");
    } else {
        for iface in iface_names {
            let boxed_open: Box<MaybeUninit<libbpf_rs::OpenObject>> = Box::new(MaybeUninit::uninit());
            let open_object: &'static mut MaybeUninit<libbpf_rs::OpenObject> = Box::leak(boxed_open);
            let skel_builder = bpf::FilterSkelBuilder::default();
            match skel_builder.open(open_object).and_then(|o| o.load()) {
                Ok(mut skel) => {
                    let ifindex = match if_nametoindex(iface.as_str()) {
                        Ok(index) => index as i32,
                        Err(e) => {
                            log::error!("failed to get interface index for '{}': {e}", iface);
                            continue;
                        }
                    };
                    if let Err(e) = bpf_attach_to_xdp(&mut skel, ifindex, Some(iface.as_str()), &config.network.ip_version) {
                        // Check if error is EAFNOSUPPORT (error 97) - IPv6 might be disabled
                        let error_str = e.to_string();
                        if error_str.contains("97") || error_str.contains("Address family not supported") {
                            match config.network.ip_version.as_str() {
                                "ipv4" => {
                                    log::warn!("Failed to attach XDP to '{}': {} (IPv6 disabled)", iface, e);
                                    log::info!("IPv4-only mode: XDP requires IPv6 to be enabled at kernel level for attachment (kernel limitation), even when processing only IPv4 packets.");
                                    log::info!("Options:");
                                    log::info!("  1. Enable IPv6 for interface: sysctl -w net.ipv6.conf.{}.disable_ipv6=0", iface);
                                    log::info!("  2. Set ip_version to 'both' in config.yaml to enable IPv6 support");
                                    log::info!("  3. Set disable_xdp: true in config.yaml to skip XDP (reduces packet filtering capabilities)");
                                    log::warn!("Continuing without XDP on interface '{}' - packet filtering will be limited", iface);
                                }
                                "ipv6" => {
                                    log::error!("Failed to attach XDP to '{}': {} (IPv6 disabled)", iface, e);
                                    log::info!("IPv6-only mode: IPv6 must be enabled for XDP attachment.");
                                    log::info!("Enable IPv6: sysctl -w net.ipv6.conf.{}.disable_ipv6=0", iface);
                                }
                                _ => {
                                    log::error!("Failed to attach XDP to '{}': {} (IPv6 may be disabled)", iface, e);
                                    log::info!("XDP requires IPv6 kernel support. Try 'sysctl -w net.ipv6.conf.{}.disable_ipv6=0' or set 'disable_xdp: true' in config.yaml", iface);
                                }
                            }
                        } else {
                            log::error!("Failed to attach XDP to '{}': {}", iface, e);
                        }
                        continue;
                    }
                    log::info!("BPF sucessfully attached to xdp on {}", iface);
                    skels.push(Arc::new(skel));
                    ifindices.push(ifindex);
                }
                Err(e) => {
                    log::warn!("failed to load BPF skeleton for '{}': {e}", iface);
                }
            }
        }

        // Initialize access rules immediately after XDP attachment
        if !skels.is_empty() {
            let _ = access_rules::init_access_rules_from_global(&skels);
            if config.mode == "agent" {
                log::info!("Access rules initialized for agent mode - network-level filtering active");
            }
        } else if !config.network.disable_xdp {
            // XDP was enabled in config but no skeletons were loaded (likely due to errors)
            log::warn!("XDP attachment failed - falling back to userland access rules enforcement");
            log::warn!("Access rules will be enforced in userland (application layer) with higher latency");
            log::info!("To suppress this warning, set 'disable_xdp: true' in config.yaml");
        }
    }


    // Create BPF statistics collector
    let bpf_stats_collector = BpfStatsCollector::new(skels.clone(), config.bpf_stats.enabled);
    if config.mode == "agent" && !skels.is_empty() {
        log::info!("BPF statistics collector initialized for agent mode (enabled: {})", config.bpf_stats.enabled);
    }

    // Create TCP fingerprinting collector
    let tcp_fingerprint_collector = TcpFingerprintCollector::new_with_config(
        skels.clone(),
        TcpFingerprintConfig::from_cli_config(&config.tcp_fingerprint)
    );
    if config.mode == "agent" && !skels.is_empty() {
        log::info!("TCP fingerprinting collector initialized for agent mode (enabled: {})", config.tcp_fingerprint.enabled);
    }

    // Set global TCP fingerprint collector for proxy access
    crate::utils::tcp_fingerprint::set_global_tcp_fingerprint_collector(tcp_fingerprint_collector.clone());

    let state = AppState {
        skels: skels.clone(),
        ifindices: ifindices.clone(),
        bpf_stats_collector,
        tcp_fingerprint_collector,
    };

    // Start the captcha verification server in a separate task
    tokio::spawn(async move {
        if let Err(e) = captcha_server::start_captcha_server().await {
            error!("Captcha server error: {}", e);
        }
    });
    info!("Captcha verification server started on 127.0.0.1:9181");

    // Start embedded ACME server if enabled
    if config.acme.enabled {
        let acme_config = config.acme.clone();
        let pingora_config = config.pingora.clone();
        let redis_config = config.redis.clone();

        tokio::spawn(async move {
            use crate::acme::embedded::{EmbeddedAcmeServer, EmbeddedAcmeConfig};
            use std::path::PathBuf;

            // Use upstreams path from pingora configuration
            let upstreams_path = PathBuf::from(&pingora_config.upstreams_conf);

            // Determine email
            let email = acme_config.email
                .unwrap_or_else(|| "admin@example.com".to_string());

            // Determine Redis URL
            let redis_url = acme_config.redis_url
                .or_else(|| if redis_config.url.is_empty() { None } else { Some(redis_config.url) });

            // Create Redis SSL config if available
            let redis_ssl = redis_config.ssl.map(|ssl| crate::acme::config::RedisSslConfig {
                ca_cert_path: ssl.ca_cert_path,
                client_cert_path: ssl.client_cert_path,
                client_key_path: ssl.client_key_path,
                insecure: ssl.insecure,
            });

            // Log storage configuration for debugging
            if let Some(ref st) = acme_config.storage_type {
                info!("ACME storage_type from config: '{}'", st);
            } else {
                warn!("ACME storage_type not set in config, will auto-detect from redis_url");
            }
            if let Some(ref ru) = redis_url {
                info!("ACME redis_url: '{}'", ru);
            } else {
                warn!("ACME redis_url not set");
            }

            let embedded_acme_config = EmbeddedAcmeConfig {
                port: acme_config.port,
                bind_ip: "127.0.0.1".to_string(),
                upstreams_path,
                email,
                storage_path: PathBuf::from(&acme_config.storage_path),
                storage_type: acme_config.storage_type.clone(),
                development: acme_config.development,
                redis_url,
                redis_ssl,
            };

            // Clone config for HTTP server before moving it
            let http_server_config = embedded_acme_config.clone();

            let acme_server = EmbeddedAcmeServer::new(embedded_acme_config);

            // Initialize domain reader
            if let Err(e) = acme_server.init_domain_reader().await {
                error!("Failed to initialize ACME domain reader: {}", e);
                return;
            }

            // Start the HTTP server first (in background) so endpoint checks can succeed
            tokio::spawn(async move {
                let http_server = EmbeddedAcmeServer::new(http_server_config);
                // Initialize domain reader for the HTTP server
                if let Err(e) = http_server.init_domain_reader().await {
                    error!("Failed to initialize domain reader for HTTP server: {}", e);
                    return;
                }
                if let Err(e) = http_server.start_server().await {
                    error!("ACME server error: {}", e);
                }
            });

            // Give the server a moment to start before processing certificates
            tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;

            // Process certificates initially (endpoint check will retry if server not ready)
            if let Err(e) = acme_server.process_certificates().await {
                warn!("Failed to process initial certificates: {}", e);
            }
        });
        info!("Embedded ACME server started on 127.0.0.1:{}", config.acme.port);
    } else {
        log::info!("Embedded ACME server disabled (acme.enabled: false)");
    }

    // Start the old Pingora proxy system in a separate thread (non-blocking)
    // Only start if mode is "proxy" (disabled in agent mode)
    if config.mode == "proxy" {
        let bpf_stats_config = config.bpf_stats.clone();
        let logging_config = config.logging.clone();
        let arxignis_config = config.arxignis.clone();
        let network_config = config.network.clone();
        let tcp_fingerprint_config = config.tcp_fingerprint.clone();
        let pingora_config = config.pingora.clone();
        std::thread::spawn(move || {
            http_proxy::start::run_with_config(Some(crate::cli::Config {
                mode: "proxy".to_string(),
                redis: Default::default(),
                network: network_config,
                arxignis: arxignis_config,
                content_scanning: Default::default(),
                logging: logging_config,
                bpf_stats: bpf_stats_config,
                tcp_fingerprint: tcp_fingerprint_config,
                daemon: Default::default(),
                pingora: pingora_config,
                acme: Default::default(),
            }));
        });
    } else {
        log::info!("Pingora proxy system disabled (mode: {})", config.mode);
    }

    let (shutdown_tx, shutdown_rx) = watch::channel(false);

    // Initialize Redis manager if Redis URL is provided
    let redis_initialized = {
        log::info!("Checking Redis configuration: url is_empty={}", config.redis.url.is_empty());
        if !config.redis.url.is_empty() {
            log::info!("Initializing Redis manager with URL: {} (prefix: {})", config.redis.url, config.redis.prefix);
            match redis::RedisManager::init(&config.redis.url, config.redis.prefix.clone(), config.redis.ssl.as_ref()).await {
                Ok(_) => {
                    log::info!("Redis manager initialized successfully");
                    true
                }
                Err(e) => {
                    log::error!("Failed to initialize Redis manager: {}", e);
                    log::error!("Certificate worker will not be started due to Redis initialization failure");
                    false
                }
            }
        } else {
            log::warn!("Redis URL is empty, skipping Redis manager initialization");
            false
        }
    };

    // Initialize worker manager
    let (mut worker_manager, _worker_shutdown_rx) = worker::WorkerManager::new();

    // Set ACME config for certificate worker to use
    worker::certificate::set_acme_config(config.acme.clone());

    // Register certificate worker only if Redis was successfully initialized
    if redis_initialized {
        // Parse proxy_certificates from config file (under pingora section)
        let certificate_path = if let Some(config_path) = &_args.config {
            std::fs::read_to_string(config_path)
                .ok()
                .and_then(|content| serde_yaml::from_str::<serde_yaml::Value>(&content).ok())
                .and_then(|yaml| {
                    // Try pingora.proxy_certificates first, then fallback to root level
                    yaml.get("pingora")
                        .and_then(|pingora| pingora.get("proxy_certificates"))
                        .or_else(|| yaml.get("proxy_certificates"))
                        .and_then(|v| v.as_str().map(|s| s.to_string()))
                })
                .unwrap_or_else(|| "/tmp/synapse-certs".to_string())
        } else {
            "/tmp/synapse-certs".to_string()
        };

        // Set proxy_certificates path for ACME certificate saving
        crate::acme::set_proxy_certificates_path(Some(certificate_path.clone()));

        let refresh_interval = 30; // 30 seconds default refresh interval
        let worker_config = worker::WorkerConfig {
            name: "certificate".to_string(),
            interval_secs: refresh_interval,
            enabled: true,
        };

        let upstreams_path = config.pingora.upstreams_conf.clone();
        let certificate_worker = worker::certificate::CertificateWorker::new(
            certificate_path.clone(),
            upstreams_path,
            refresh_interval
        );

        if let Err(e) = worker_manager.register_worker(worker_config, certificate_worker) {
            log::error!("Failed to register certificate worker: {}", e);
        } else {
            log::info!("Registered certificate worker (path: {}, interval: {}s)", certificate_path, refresh_interval);
        }
    }

    // Validate API key if provided
    if !config.arxignis.base_url.is_empty() && !config.arxignis.api_key.is_empty() {
        if let Err(e) = validate_api_key(
            &config.arxignis.base_url,
            &config.arxignis.api_key,
        ).await {
            log::error!("API key validation failed: {}", e);
            return Err(anyhow::anyhow!("API key validation failed: {}", e));
        }
    }

    // Initialize content scanning from CLI config
    let content_scanning_config = ContentScanningConfig {
        enabled: config.content_scanning.enabled,
        clamav_server: config.content_scanning.clamav_server.clone(),
        max_file_size: config.content_scanning.max_file_size,
        scan_content_types: config.content_scanning.scan_content_types.clone(),
        skip_extensions: config.content_scanning.skip_extensions.clone(),
        scan_expression: config.content_scanning.scan_expression.clone(),
    };
    if let Err(e) = init_content_scanner(content_scanning_config) {
        log::warn!("Failed to initialize content scanner: {}", e);
    } else {
        log::info!("Content scanner initialized successfully");
    }

    // Initialize access log sender configuration
    let log_sender_config = LogSenderConfig {
        enabled: config.arxignis.log_sending_enabled,
        base_url: config.arxignis.base_url.clone(),
        api_key: config.arxignis.api_key.clone(),
        batch_size_limit: 5000,        // Default: 5000 logs per batch
        batch_size_bytes: 5 * 1024 * 1024, // Default: 5MB
        batch_timeout_secs: 10,        // Default: 10 seconds
        include_request_body: false,   // Default: disabled
        max_body_size: config.arxignis.max_body_size,
    };
    set_log_sender_config(log_sender_config);

    // Register log sender worker if log sending is enabled
    if config.arxignis.log_sending_enabled && !config.arxignis.api_key.is_empty() {
        log::info!("Event sending to arxignis server enabled with unified queue (10s timeout, 5MB limit)");

        let check_interval = 1; // Check every 1 second
        let worker_config = worker::WorkerConfig {
            name: "log_sender".to_string(),
            interval_secs: check_interval,
            enabled: true,
        };

        let log_sender_worker = worker::log::LogSenderWorker::new(check_interval);

        if let Err(e) = worker_manager.register_worker(worker_config, log_sender_worker) {
            log::error!("Failed to register log sender worker: {}", e);
        } else {
            log::info!("Registered log sender worker (interval: {}s)", check_interval);
        }
    } else {
        log::info!("Event sending to arxignis server disabled (enabled: {}, api_key configured: {})",
                   config.arxignis.log_sending_enabled, !config.arxignis.api_key.is_empty());
    }

    // Build list of interfaces to attach
    if !config.arxignis.base_url.is_empty() && !config.arxignis.api_key.is_empty() {
        if let Err(e) = init_config(
            config.arxignis.base_url.clone(),
            config.arxignis.api_key.clone(),
        ).await {
            log::warn!("Failed to initialize HTTP filter with config: {}", e);
        }

        // Initialize threat intelligence client
        if let Err(e) = threat::init_threat_client(
            config.arxignis.base_url.clone(),
            config.arxignis.api_key.clone(),
        ).await {
            log::warn!("Failed to initialize threat client: {}", e);
        } else {
            log::info!("Threat intelligence client initialized");
        }

        // Initialize captcha client if configuration is provided
        if let (Some(site_key), Some(secret_key), Some(jwt_secret)) = (
            &config.arxignis.captcha.site_key,
            &config.arxignis.captcha.secret_key,
            &config.arxignis.captcha.jwt_secret
        ) {
            let captcha_config = CaptchaConfig {
                site_key: site_key.clone(),
                secret_key: secret_key.clone(),
                jwt_secret: jwt_secret.clone(),
                provider: CaptchaProvider::from_str(&config.arxignis.captcha.provider).unwrap_or(CaptchaProvider::HCaptcha),
                token_ttl_seconds: config.arxignis.captcha.token_ttl,
                validation_cache_ttl_seconds: config.arxignis.captcha.cache_ttl,
            };

            if let Err(e) = init_captcha_client(
                captcha_config,
            ).await {
                log::warn!("Failed to initialize captcha client: {}", e);
            } else {
                log::info!("Captcha client initialized with provider: {}", config.arxignis.captcha.provider);
                // Start captcha cache cleanup task
                start_cache_cleanup_task().await;
            }
        } else {
            log::info!("Captcha client not initialized (missing site_key, secret_key, or jwt_secret)");
        }
    } else {
        log::warn!("No API credentials provided, HTTP filter will not be initialized");
    }

    // Access rules were already initialized after XDP attachment above

    // Register config worker to fetch and apply configuration periodically
    if !config.arxignis.base_url.is_empty() && !config.arxignis.api_key.is_empty() {
        let refresh_interval = 10; // 10 seconds config refresh interval
        let worker_config = worker::WorkerConfig {
            name: "config".to_string(),
            interval_secs: refresh_interval,
            enabled: true,
        };

        let config_worker = worker::config::ConfigWorker::new(
            config.arxignis.base_url.clone(),
            config.arxignis.api_key.clone(),
            refresh_interval,
            state.skels.clone(),
        );

        if let Err(e) = worker_manager.register_worker(worker_config, config_worker) {
            log::error!("Failed to register config worker: {}", e);
        } else {
            if config.mode == "agent" {
                log::info!("Registered config worker for agent mode (interval: {}s) - fetches access rules, WAF rules, and content scanning config", refresh_interval);
            } else {
                log::info!("Registered config worker (interval: {}s) - fetches access rules, WAF rules, and content scanning config", refresh_interval);
            }
        }
    } else {
        log::info!("Skipping config worker (no API credentials provided)");
    }

    // Start BPF statistics logging task
    let bpf_stats_handle = if config.bpf_stats.enabled && !state.skels.is_empty() {
        let collector = state.bpf_stats_collector.clone();
        let log_interval = config.bpf_stats.log_interval_secs;
        let shutdown = shutdown_rx.clone();
        if config.mode == "agent" {
            log::info!("Starting BPF statistics logging for agent mode (interval: {}s)", log_interval);
        }
        Some(start_bpf_stats_logging(collector, log_interval, shutdown))
    } else {
        if config.mode == "agent" {
            log::warn!("BPF statistics logging disabled in agent mode - enable bpf_stats.enabled in config");
        } else {
            log::info!("Skipping BPF statistics logging (disabled or XDP not available)");
        }
        None
    };

    // Start dropped IP events logging task
    let dropped_ip_events_handle = if config.bpf_stats.enabled &&
                                       config.bpf_stats.enable_dropped_ip_events &&
                                       !state.skels.is_empty() {
        let collector = state.bpf_stats_collector.clone();
        let log_interval = config.bpf_stats.dropped_ip_events_interval_secs;
        let shutdown = shutdown_rx.clone();
        Some(start_dropped_ip_events_logging(collector, log_interval, shutdown))
    } else {
        log::info!("Skipping dropped IP events logging (disabled or XDP not available)");
        None
    };

    // Start TCP fingerprinting statistics logging task
    let tcp_fingerprint_stats_handle = if config.tcp_fingerprint.enabled && !state.skels.is_empty() {
        let collector = state.tcp_fingerprint_collector.clone();
        let log_interval = config.tcp_fingerprint.log_interval_secs;
        let shutdown = shutdown_rx.clone();
        let state_clone = Arc::new(state.clone());
        if config.mode == "agent" {
            log::info!("Starting TCP fingerprinting statistics logging for agent mode (interval: {}s)", log_interval);
        }
        Some(start_tcp_fingerprint_stats_logging(collector, log_interval, shutdown, state_clone))
    } else {
        if config.mode == "agent" {
            log::warn!("TCP fingerprinting statistics logging disabled in agent mode - enable tcp_fingerprint.enabled in config");
        } else {
            log::info!("Skipping TCP fingerprinting statistics logging (disabled or XDP not available)");
        }
        None
    };

    // Start TCP fingerprinting events logging task
    let tcp_fingerprint_events_handle = if config.tcp_fingerprint.enabled &&
                                           config.tcp_fingerprint.enable_fingerprint_events &&
                                           !state.skels.is_empty() {
        let collector = state.tcp_fingerprint_collector.clone();
        let log_interval = config.tcp_fingerprint.fingerprint_events_interval_secs;
        let shutdown = shutdown_rx.clone();
        let state_clone = Arc::new(state.clone());
        Some(start_tcp_fingerprint_events_logging(collector, log_interval, shutdown, state_clone))
    } else {
        log::info!("Skipping TCP fingerprinting events logging (disabled or XDP not available)");
        None
    };

    signal::ctrl_c().await?;
    log::info!("Shutdown signal received, stopping servers...");
    let _ = shutdown_tx.send(true);

    if let Some(handle) = bpf_stats_handle
        && let Err(err) = handle.await
    {
        log::error!("bpf-stats task join error: {err}");
    }

    if let Some(handle) = dropped_ip_events_handle
        && let Err(err) = handle.await
    {
        log::error!("dropped-ip-events task join error: {err}");
    }

    if let Some(handle) = tcp_fingerprint_stats_handle
        && let Err(err) = handle.await
    {
        log::error!("tcp-fingerprint-stats task join error: {err}");
    }

    if let Some(handle) = tcp_fingerprint_events_handle
        && let Err(err) = handle.await
    {
        log::error!("tcp-fingerprint-events task join error: {err}");
    }

    // Shutdown all workers
    worker_manager.shutdown();
    worker_manager.wait_for_all().await;

    // Detach XDP programs from interfaces
    if !ifindices.is_empty() {
        log::info!("Detaching XDP programs from {} interfaces...", ifindices.len());
        for ifindex in ifindices {
            if let Err(e) = bpf_detach_from_xdp(ifindex) {
                log::error!("Failed to detach XDP from interface {}: {}", ifindex, e);
            }
        }
    }

    Ok(())
}

/// Start a background task that logs BPF statistics periodically
fn start_bpf_stats_logging(
    collector: BpfStatsCollector,
    log_interval_secs: u64,
    mut shutdown: tokio::sync::watch::Receiver<bool>,
) -> tokio::task::JoinHandle<()> {
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(log_interval_secs));

        loop {
            tokio::select! {
                _ = shutdown.changed() => {
                    if *shutdown.borrow() { break; }
                }
                _ = interval.tick() => {
                    if let Err(e) = collector.log_stats() {
                        log::warn!("Failed to log BPF statistics: {}", e);
                    }
                }
            }
        }

        log::info!("BPF statistics logging task stopped");
    })
}

/// Start a background task that logs dropped IP events periodically
fn start_dropped_ip_events_logging(
    collector: BpfStatsCollector,
    log_interval_secs: u64,
    mut shutdown: tokio::sync::watch::Receiver<bool>,
) -> tokio::task::JoinHandle<()> {
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(log_interval_secs));

        loop {
            tokio::select! {
                _ = shutdown.changed() => {
                    if *shutdown.borrow() { break; }
                }
                _ = interval.tick() => {
                    if let Err(e) = collector.log_dropped_ip_events() {
                        log::warn!("Failed to log dropped IP events: {}", e);
                    }
                }
            }
        }

        log::info!("Dropped IP events logging task stopped");
    })
}

/// Start a background task that logs TCP fingerprinting statistics periodically
fn start_tcp_fingerprint_stats_logging(
    collector: TcpFingerprintCollector,
    log_interval_secs: u64,
    mut shutdown: tokio::sync::watch::Receiver<bool>,
    _state: Arc<AppState>,
) -> tokio::task::JoinHandle<()> {
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(log_interval_secs));

        loop {
            tokio::select! {
                _ = shutdown.changed() => {
                    if *shutdown.borrow() { break; }
                }
                _ = interval.tick() => {
                    if let Err(e) = collector.log_stats() {
                        log::warn!("Failed to log TCP fingerprinting statistics: {}", e);
                    }
                }
            }
        }

        log::info!("TCP fingerprinting statistics logging task stopped");
    })
}

/// Start a background task that logs TCP fingerprinting events periodically
fn start_tcp_fingerprint_events_logging(
    collector: TcpFingerprintCollector,
    log_interval_secs: u64,
    mut shutdown: tokio::sync::watch::Receiver<bool>,
    _state: Arc<AppState>,
) -> tokio::task::JoinHandle<()> {
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(log_interval_secs));

        loop {
            tokio::select! {
                _ = shutdown.changed() => {
                    if *shutdown.borrow() { break; }
                }
                _ = interval.tick() => {
                    if let Err(e) = collector.log_fingerprint_events() {
                        log::warn!("Failed to log TCP fingerprinting events: {}", e);
                    }
                }
            }
        }

        log::info!("TCP fingerprinting events logging task stopped");
    })
}
